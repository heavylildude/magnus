const Database=require("better-sqlite3");const path=require("path");const fs=require("fs");class ActiveMemory{constructor(dbPath="database/magnus_memory.sqlite3",config={}){this.dbPath=dbPath;this.maxHistoryMessages=config.maxHistoryMessages||20;this.contextTurns=config.contextTurns||5;const dir=path.dirname(this.dbPath);if(!fs.existsSync(dir)){fs.mkdirSync(dir,{recursive:true})}this.db=new Database(this.dbPath);this.initialize()}initialize(){try{this.db.exec(`\n                CREATE TABLE IF NOT EXISTS history (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    role TEXT NOT NULL,\n                    content TEXT NOT NULL,\n                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                    metadata TEXT\n                );\n                \n                CREATE INDEX IF NOT EXISTS idx_timestamp ON history(timestamp);\n            `);console.log("✓ Active memory database initialized")}catch(error){console.error("Memory init failed:",error)}}addMessage(role,content,metadata={}){if(!content||content.trim()==="")return;try{const stmt=this.db.prepare(`\n                INSERT INTO history (role, content, metadata)\n                VALUES (?, ?, ?)\n            `);stmt.run(role,content,JSON.stringify(metadata))}catch(error){console.error("Failed to add message:",error)}}getRawHistory(limit=null){const queryLimit=limit||this.maxHistoryMessages;try{const stmt=this.db.prepare(`\n                SELECT id, role, content, timestamp, metadata\n                FROM history\n                ORDER BY id DESC\n                LIMIT ?\n            `);return stmt.all(queryLimit).reverse()}catch(error){console.error("Failed to get raw history:",error);return[]}}getSmartContext(currentUserQuery="",turnsToInclude=null){const turns=turnsToInclude||this.contextTurns;const rawHistory=this.getRawHistory(turns*2);if(rawHistory.length===0)return[];const keywords=this.extractKeywords(currentUserQuery);const filtered=rawHistory.filter(msg=>{if(msg.role==="assistant")return true;if(keywords.length>0){const msgKeywords=this.extractKeywords(msg.content);const overlap=keywords.some(kw=>msgKeywords.includes(kw));if(overlap)return true}const msgAge=Date.now()-new Date(msg.timestamp).getTime();const fiveMinutesMs=5*60*1e3;if(msgAge<fiveMinutesMs)return true;return false});return filtered.slice(-turns*2)}extractKeywords(text){if(!text)return[];const stopwords=new Set(["the","a","an","and","or","but","is","are","was","were","be","been","being","have","has","had","do","does","did","will","would","could","should","may","might","must","can","in","on","at","to","for","of","with","by","from","up","about","out","if","as","it","that","this","what","which","who","when","where","why","how","all","each","every","both","few","more","most","other","some","such","no","nor","not","only","same","so","than","too","very","just","you","i","we","he","she","me","him","her","us","them"]);return text.toLowerCase().split(/\s+/).filter(word=>word.length>3&&!stopwords.has(word)).slice(0,10)}buildContextString(currentUserQuery="",fileStorage=null){const smartContext=this.getSmartContext(currentUserQuery);if(smartContext.length===0){return""}let contextStr="CONVERSATION HISTORY (for context):\n";smartContext.forEach(msg=>{const role=msg.role==="user"?"User":"Assistant";let metadata={};try{metadata=msg.metadata?JSON.parse(msg.metadata):{}}catch(e){}contextStr+=`${role}: ${msg.content.substring(0,200)}${msg.content.length>200?"...":""}\n`;if(metadata.attachments&&fileStorage){metadata.attachments.forEach(att=>{const file=fileStorage.get(att.fileId);if(file&&file.content){contextStr+=`  [Attachment: ${att.fileName}]\n`;const preview=file.content.substring(0,500);contextStr+=`  ${preview}${file.content.length>500?"...":""}\n`}})}});contextStr+="\n---\n\n";return contextStr}clearHistory(){try{this.db.exec("DELETE FROM history");console.log("✓ History cleared")}catch(error){console.error("Failed to clear history:",error)}}getMessageCount(){try{const stmt=this.db.prepare("SELECT COUNT(*) as count FROM history");return stmt.get().count}catch(error){return 0}}close(){this.db.close()}}module.exports=ActiveMemory;