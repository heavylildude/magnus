const DiffMatchPatch=require("diff-match-patch");class SmartInjector{constructor(){this.dmp=new DiffMatchPatch;this.dmp.Match_Threshold=.5;this.dmp.Match_Distance=1e4}apply(fileContent,change){console.log("[MAGNUS] Smart Injector received change:",change.type);if(change.type==="replace"&&change.newContent){return this._stripMarkdown(change.newContent)}if(change.type==="diff"&&change.diffContent){return this._applyUnifiedDiff(fileContent,change.diffContent)}if(change.type==="operation"){return this._applyOperation(fileContent,change)}if(change.type==="manual-insert"){return this._applyManualInsert(fileContent,change)}console.warn("[MAGNUS] Unknown change type, returning original");return fileContent}_applyUnifiedDiff(fileContent,diffContent){const decodedDiff=this._decodeHtmlEntities(diffContent);const cleanDiff=this._stripMarkdown(decodedDiff);const lines=fileContent.split(/\r?\n/);const diffLines=cleanDiff.split(/\r?\n/);console.log("[MAGNUS] Parsing unified diff...");const hunks=this._parseUnifiedDiff(diffLines,fileContent);if(hunks.length===0){console.warn("[MAGNUS] No valid hunks found in diff");if(!fileContent||fileContent.trim().length===0){console.log("[MAGNUS] File is empty. Treating lazy diff as new content.");return cleanDiff}const isCssLike=cleanDiff.includes("{")&&cleanDiff.includes("}")&&cleanDiff.includes(":");if(isCssLike){console.log("[MAGNUS] Lazy diff looks like CSS. Appending to file.");return fileContent+"\n\n"+cleanDiff}throw new Error('Missing line numbers (@@ ... @@). Cannot auto-apply. Please use "Insert" to place code manually.')}let result=[...lines];let offset=0;for(const hunk of hunks){const applied=this._applyHunk(result,hunk,offset);if(applied.success){result=applied.lines;offset=applied.offset;console.log(`[MAGNUS] Hunk applied successfully at line ${hunk.oldStart+offset}`)}else{console.warn(`[MAGNUS] Hunk failed at line ${hunk.oldStart}, trying fuzzy match...`);const fuzzy=this._applyHunkFuzzy(result,hunk);if(fuzzy.success){result=fuzzy.lines;console.log("[MAGNUS] Fuzzy match succeeded!")}else{console.error("[MAGNUS] Hunk could not be applied:",hunk);throw new Error(`Failed to apply hunk at line ${hunk.oldStart}`)}}}return result.join("\n")}_parseUnifiedDiff(diffLines,fileContent){const hunks=[];let currentHunk=null;const fileHasContent=fileContent&&fileContent.trim().length>0;for(let i=0;i<diffLines.length;i++){const line=diffLines[i];if(line.startsWith("@@")){if(currentHunk)hunks.push(currentHunk);const match=line.match(/@@\s+-(\d+)(?:,(\d+))?\s+\+(\d+)(?:,(\d+))?\s+@@/);if(match){const oldStart=parseInt(match[1]);const oldCount=parseInt(match[2]||"1");if(fileHasContent&&oldStart===0&&oldCount===0){console.error("[MAGNUS] âŒ BOGUS DIFF DETECTED!");console.error('[MAGNUS] The diff uses @@ -0,0 which means "empty file", but the file has existing content.');console.error("[MAGNUS] This usually means the AI model didn't examine the actual file content.");throw new Error('Invalid diff: @@ -0,0 means "empty file" but you\'re modifying existing content. The model needs to generate a proper diff with correct line numbers from the actual file.')}currentHunk={oldStart:oldStart,oldCount:oldCount,newStart:parseInt(match[3]),newCount:parseInt(match[4]||"1"),lines:[]}}}else if(currentHunk&&(line.startsWith("+")||line.startsWith("-")||line.startsWith(" "))){currentHunk.lines.push(line)}}if(currentHunk)hunks.push(currentHunk);return hunks}_applyHunk(fileLines,hunk,offset,looseMode=false){const startLine=hunk.oldStart-1+offset;let currentLine=startLine;const newLines=[...fileLines];let linesAdded=0;let linesRemoved=0;for(let i=0;i<hunk.lines.length;i++){const diffLine=hunk.lines[i];if(diffLine.startsWith(" ")){const expectedContent=diffLine.slice(1);const actualContent=newLines[currentLine];if(actualContent===undefined){if(looseMode){console.warn("[MAGNUS] Loose Mode: End of file reached during context check.");break}return{success:false}}if(!this._linesMatch(actualContent,expectedContent)){if(looseMode){if(actualContent.trim()===""||expectedContent.trim()===""){console.warn("[MAGNUS] Loose Mode: Skipping empty line mismatch.");if(actualContent.trim()==="")currentLine++;continue}console.warn(`[MAGNUS] Loose Mode: Context mismatch at line ${currentLine}.`)}else{return{success:false}}}currentLine++}}currentLine=startLine;for(const diffLine of hunk.lines){if(diffLine.startsWith("-")){newLines.splice(currentLine,1);linesRemoved++}else if(diffLine.startsWith("+")){const newContent=diffLine.slice(1);let isDuplicate=false;if(looseMode){const existingLine=newLines[currentLine];if(existingLine!==undefined&&this._linesMatch(existingLine,newContent)){console.log(`[MAGNUS] Loose Mode: Skipping duplicate insertion of line: "${newContent.trim()}"`);isDuplicate=true}}if(isDuplicate){currentLine++}else{newLines.splice(currentLine,0,newContent);currentLine++;linesAdded++}}else{currentLine++}}return{success:true,lines:newLines,offset:offset+(linesAdded-linesRemoved)}}_applyHunkFuzzy(fileLines,hunk){const patternLengthLimit=this.dmp.Match_MaxBits>0?this.dmp.Match_MaxBits-1:31;let bestAnchor=null;let anchorOffset=0;for(let i=0;i<hunk.lines.length;i++){const line=hunk.lines[i];if(line.startsWith(" ")&&i+1<hunk.lines.length&&(hunk.lines[i+1].startsWith("+")||hunk.lines[i+1].startsWith("-"))){bestAnchor=line.slice(1);anchorOffset=i;break}}if(!bestAnchor){const firstContextIdx=hunk.lines.findIndex(l=>l.startsWith(" "));if(firstContextIdx!==-1){bestAnchor=hunk.lines[firstContextIdx].slice(1);anchorOffset=firstContextIdx}}if(!bestAnchor){console.warn("[MAGNUS] No context lines in hunk for fuzzy matching.");return{success:false}}const fileContent=fileLines.join("\n");let searchPattern=bestAnchor;if(searchPattern.length>patternLengthLimit){console.warn(`[MAGNUS] WARNING: Fuzzy patch pattern is too long. Truncating.`);searchPattern=searchPattern.substring(0,patternLengthLimit)}let indices=this._findAllOccurrences(fileContent,searchPattern);if(indices.length===0){const trimmedAnchor=bestAnchor.trim();if(trimmedAnchor!==searchPattern&&trimmedAnchor.length>10){console.log("[MAGNUS] Exact anchor match failed. Trying trimmed anchor...");let trimmedPattern=trimmedAnchor;if(trimmedPattern.length>patternLengthLimit){trimmedPattern=trimmedPattern.substring(0,patternLengthLimit)}indices=this._findAllOccurrences(fileContent,trimmedPattern)}}if(indices.length===0){console.log("[MAGNUS] Exact/Trimmed match failed. Trying DMP fuzzy match...");const fuzzyIdx=this.dmp.match_main(fileContent,searchPattern,0);if(fuzzyIdx===-1){console.error("[MAGNUS] Fuzzy match failed - anchor not found");return{success:false}}indices.push(fuzzyIdx)}if(indices.length>1){console.error(`[MAGNUS] Ambiguous match - found ${indices.length} occurrences`);return{success:false}}const beforeMatch=fileContent.substring(0,indices[0]);const lineStartIndex=beforeMatch.lastIndexOf("\n")+1;const matchLineNumber=fileContent.substring(0,lineStartIndex).split("\n").length-1;let oldLinesBeforeAnchor=0;for(let i=0;i<anchorOffset;i++){if(hunk.lines[i].startsWith(" ")||hunk.lines[i].startsWith("-")){oldLinesBeforeAnchor++}}const calculatedOldStart=matchLineNumber+1-oldLinesBeforeAnchor;console.log(`[MAGNUS] Fuzzy match found anchor at line ${matchLineNumber+1}. Calculated hunk start: ${calculatedOldStart}`);const adjustedHunk={...hunk,oldStart:calculatedOldStart};return this._applyHunk(fileLines,adjustedHunk,0,true)}_applyOperation(fileContent,op){const cleanNewContent=this._stripMarkdown(op.newContent||"");const cleanOp={...op,newContent:cleanNewContent};const lines=fileContent.split(/\r?\n/);if(this._hasValidLines(cleanOp,lines)){console.log(`[MAGNUS] Plan A: Line surgery on lines ${cleanOp.startLine}-${cleanOp.endLine}...`);const targetLines=lines.slice(cleanOp.startLine-1,cleanOp.endLine);const targetText=targetLines.join("\n");if(this._verifyAnchorMatch(targetText,cleanOp.originalContent)){console.log("[MAGNUS] Plan A: Verified. Executing swap.");return this._executeLineOp(lines,cleanOp).join("\n")}else{console.warn("[MAGNUS] Plan A Failed: Content mismatch, engaging fallback.")}}console.log("[MAGNUS] Plan B: Content search...");try{return this._executeContentOp(fileContent,cleanOp)}catch(e){console.error(`[MAGNUS] All Plans Failed: ${e.message}`);return fileContent}}_applyManualInsert(fileContent,op){console.log(`[MAGNUS] Manual Insert: Applying code at line ${op.startLine}.`);const lines=fileContent.split(/\r?\n/);if(!this._hasValidLines(op,lines)){const errorMsg=`[MAGNUS] Manual Insert Failed: Invalid start line ${op.startLine}.`;console.error(errorMsg);throw new Error(errorMsg)}const startIdx=op.startLine-1;const deleteCount=op.endLine>op.startLine?op.endLine-op.startLine:0;const newContentLines=this._stripMarkdown(op.newContent||"").split(/\r?\n/);lines.splice(startIdx,deleteCount,...newContentLines);return lines.join("\n")}_stripMarkdown(text){if(!text)return"";const fenceRegex=/^```[a-zA-Z]*\n([\s\S]*?)\n```$/;const match=text.match(fenceRegex);if(match)return match[1];return text.replace(/^```[a-z]*\s*$/gm,"").trim()}_decodeHtmlEntities(str){if(!str)return"";return str.replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&")}_hasValidLines(op,allLines){return typeof op.startLine==="number"&&op.startLine>0&&op.startLine<=allLines.length}_verifyAnchorMatch(textA,textB){if(!textB)return true;const cleanA=textA.replace(/\s+/g,"");const cleanB=textB.replace(/\s+/g,"");return cleanA.includes(cleanB)||cleanB.includes(cleanA)}_linesMatch(lineA,lineB){return lineA.trim()===lineB.trim()}_executeLineOp(lines,op){const startIdx=op.startLine-1;const newLines=[...lines];const newContentLines=op.newContent.split(/\r?\n/);if(op.type==="replace"||op.type==="operation"){const deleteCount=op.endLine-op.startLine+1;newLines.splice(startIdx,deleteCount,...newContentLines)}else if(op.type==="insert"){newLines.splice(startIdx,0,...newContentLines)}else if(op.type==="delete"){const deleteCount=op.endLine-op.startLine+1;newLines.splice(startIdx,deleteCount)}return newLines}_executeContentOp(fullText,op){const anchor=op.originalContent;if(!anchor)throw new Error("Plan B Aborted: No anchor provided.");const patternLengthLimit=this.dmp.Match_MaxBits>0?this.dmp.Match_MaxBits-1:31;let searchPattern=anchor;if(searchPattern.length>patternLengthLimit){console.warn(`[MAGNUS] WARNING: Content search pattern is too long for fuzzy match. Truncating.`);searchPattern=searchPattern.substring(0,patternLengthLimit)}const isTiny=anchor.length<15;const indices=this._findAllOccurrences(fullText,anchor);if(indices.length===0){const fuzzyIdx=this.dmp.match_main(fullText,searchPattern,0);if(fuzzyIdx===-1)throw new Error("Context not found in file.");return this._performStringSwap(fullText,fuzzyIdx,anchor.length,op)}if(indices.length>1){throw new Error(`Ambiguous Match: Found ${indices.length} occurrences. Manual intervention required.`)}if(isTiny&&indices.length>1){throw new Error("Anchor too short and not unique. High risk of bogus injection.")}return this._performStringSwap(fullText,indices[0],anchor.length,op)}_findAllOccurrences(text,search){const indices=[];let pos=text.indexOf(search);while(pos!==-1){indices.push(pos);pos=text.indexOf(search,pos+1)}return indices}_performStringSwap(fullText,startIdx,length,op){const before=fullText.substring(0,startIdx);if(op.type==="replace"||op.type==="operation"){const after=fullText.substring(startIdx+length);return before+op.newContent+after}if(op.type==="insert"){const after=fullText.substring(startIdx+length);return before+fullText.substring(startIdx,startIdx+length)+"\n"+op.newContent+after}if(op.type==="delete"){const after=fullText.substring(startIdx+length);return before+after}return fullText}}module.exports=SmartInjector;